<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Sbt | Eugene Zhulenev]]></title>
  <link href="http://eugenezhulenev.com/blog/categories/sbt/atom.xml" rel="self"/>
  <link href="http://eugenezhulenev.com/"/>
  <updated>2015-06-04T16:29:57-04:00</updated>
  <id>http://eugenezhulenev.com/</id>
  <author>
    <name><![CDATA[Eugene Zhulenev]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Running Spark Tests in Standalone Cluster]]></title>
    <link href="http://eugenezhulenev.com/blog/2014/10/18/run-tests-in-standalone-spark-cluster/"/>
    <updated>2014-10-18T21:01:15-04:00</updated>
    <id>http://eugenezhulenev.com/blog/2014/10/18/run-tests-in-standalone-spark-cluster</id>
    <content type="html"><![CDATA[<p>Unit testing Spark Applications with standalone Apache Spark Cluster.</p>

<blockquote>
  <p>The code for this application app can be found on <a href="https://github.com/ezhulenev/spark-testing">Github</a></p>
</blockquote>

<h3 id="running-spark-applications">Running Spark Applications</h3>

<p>To be able to run Spark jobs, Spark cluster needs to have all classes used by your application in it’s classpath.
You can put manually all jar files required by your application to Spark nodes, but it’s not cool.
Another solution is to manually set jar files that required to distribute to worker nodes
when you create SparkConf. One way to do it, is to package your application as a “fat-jar”,
so you need to distribute only single jar.
Industry standard for packaging Spark application is <a href="https://github.com/sbt/sbt-assembly">sbt-assembly</a> plugin,
and it’s used by Spark itself.</p>

<h3 id="unit-testing-spark-applications">Unit Testing Spark Applications</h3>

<p>If you need to test your Spark application, easiest way is to create local Spark Context for each test, or maybe shared between all tests.
When Spark is running in local mode, it’s running in the same JVM as your tests with same jar files in classpath.</p>

<p>If your tests requires data that doesn’t fit into single node, for example in integration or acceptance tests,
obvious solution is to run them in standalone Spark cluster
with sufficient number of nodes. At this time everything becomes more difficult. Now you need to package you application with tests
in single jar file, and submit it to Spark cluster with each test.</p>

<!-- more -->

<h3 id="example-application">Example Application</h3>

<p>To show how to run and test Spark applications I prepared very <a href="https://github.com/ezhulenev/spark-testing">simple application</a>.
It uses <a href="https://github.com/ezhulenev/scala-openbook">Scala OpenBook</a>
library to parse <a href="http://www.nyxdata.com/Data-Products/NYSE-OpenBook-History">NYSE OpenBook</a> messages (orders log from New York Stock Exchange),
distribute them to cluster as RDD, and count Buy and Sell orders by ticker.
Only purpose of this application is to have dependency on a library that for sure is not available on Spark nodes.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="type">class</span> <span class="class">OrdersFunctions</span>(<span class="annotation">@transient</span> <span class="key">sc</span>: SparkContext, <span class="key">orders</span>: <span class="predefined-type">Iterator</span>[OpenBookMsg]) <span class="directive">extends</span> <span class="predefined-type">Serializable</span> {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="directive">private</span> val ordersRDD = sc.parallelize(orders.toSeq)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">def</span> <span class="function">countBuyOrders</span>(): <span class="predefined-type">Map</span>[<span class="predefined-type">String</span>, <span class="predefined-type">Long</span>] = countOrders(OrderFunctions.isBuySide)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">def</span> <span class="function">countSellOrders</span>(): <span class="predefined-type">Map</span>[<span class="predefined-type">String</span>, <span class="predefined-type">Long</span>] = countOrders(OrderFunctions.isSellSide)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="directive">private</span> <span class="keyword">def</span> <span class="function">countOrders</span>(<span class="key">filter</span>: OpenBookMsg =&amp;gt; <span class="predefined-type">Boolean</span>): <span class="predefined-type">Map</span>[<span class="predefined-type">String</span>, <span class="predefined-type">Long</span>] =
    ordersRDD.filter(filter).
      map(order =&amp;gt; (order.symbol, order)).
      countByKey().toMap&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;}
</pre></div>
</div>
 </figure></notextile></div></p>

<p> </p>

<h3 id="assembly-main-application">Assembly Main Application</h3>

<p>Add sbt-assembly plugin in project/plugin.sbt</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
addSbtPlugin(<span class="error">“</span>com.eed3si9n<span class="error">”</span> % <span class="error">“</span>sbt-assembly<span class="error">”</span> % <span class="error">“</span><span class="float">0.11</span><span class="float">.2</span><span class="error">”</span>)
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Add assembly settings to build.sbt</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// Merge strategy shared between app &amp;amp; test&lt;/p&gt;</span>

&lt;p&gt;val <span class="key">sharedMergeStrategy</span>: (<span class="predefined-type">String</span> =&amp;gt; MergeStrategy) =&amp;gt; <span class="predefined-type">String</span> =&amp;gt; MergeStrategy =
  old =&amp;gt; {
    <span class="keyword">case</span> x <span class="keyword">if</span> x.startsWith(<span class="error">“</span>META-INF/ECLIPSEF.RSA<span class="error">”</span>) =&amp;gt; MergeStrategy.last
    <span class="keyword">case</span> x <span class="keyword">if</span> x.startsWith(<span class="error">“</span>META-INF/mailcap<span class="error">”</span>) =&amp;gt; MergeStrategy.last
    <span class="keyword">case</span> x <span class="keyword">if</span> x.endsWith(<span class="error">“</span>plugin.properties<span class="error">”</span>) =&amp;gt; MergeStrategy.last
    <span class="keyword">case</span> x =&amp;gt; old(x)
  }&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Load Assembly Settings&lt;/p&gt;</span>

&lt;p&gt;assemblySettings&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Assembly App&lt;/p&gt;</span>

&lt;p&gt;mainClass <span class="keyword">in</span> assembly := Some(<span class="error">“</span>com.github.ezhulenev.spark.RunSparkApp<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;jarName <span class="keyword">in</span> assembly := <span class="error">“</span>spark-testing-example-app.jar<span class="error">”</span>&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;mergeStrategy <span class="keyword">in</span> assembly <span class="error">«</span>= (mergeStrategy <span class="keyword">in</span> assembly)(sharedMergeStrategy)
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Inside your application you need to create SparkConf and add current jar to it.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
  <span class="keyword">new</span> SparkConf().
      setMaster(<span class="error">“</span><span class="key">spark</span>:<span class="comment">//spark-host:7777”).</span>
      setJars(SparkContext.jarOfClass(<span class="local-variable">this</span>.getClass).toSeq).
      setAppName(<span class="error">“</span>SparkTestingExample<span class="error">”</span>)
</pre></div>
</div>
 </figure></notextile></div></p>

<p>After that you can use assembly command, and run assembled application in your Spark Cluster</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
&amp;gt; sbt assembly
&amp;gt; java -Dspark.master=spark://spark-host:7777 target/scala_2.10/spark-testing-example-app.jar
</pre></div>
</div>
 </figure></notextile></div></p>

<p> </p>

<h3 id="assembly-tests">Assembly Tests</h3>

<p>First step to run tests in standalone Spark Cluster is to package all main and test classes into single jar, that will be
transfered to each worker node before running tests. It’s very similar to assemblying main app.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// Assembly Tests&lt;/p&gt;</span>

&lt;p&gt;Project.inConfig(Test)(assemblySettings)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;jarName <span class="keyword">in</span> (Test, assembly) := <span class="error">“</span>spark-testing-example-tests.jar<span class="error">”</span>&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;mergeStrategy <span class="keyword">in</span> (Test, assembly) <span class="error">«</span>= (mergeStrategy <span class="keyword">in</span> assembly)(sharedMergeStrategy)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;test <span class="keyword">in</span> (Test, assembly) := {} <span class="comment">// disable tests in assembly</span>
</pre></div>
</div>
 </figure></notextile></div></p>

<p>I wrote simple sbt plugin that has <code>test-assembly</code> task. First this task assemblies jar
file with test classes and all dependencies, then set it’s location
to environment variable, and then starts tests.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
object TestWithSparkPlugin <span class="directive">extends</span> sbt.Plugin {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">import</span> <span class="include">TestWithSparkKeys._</span>
  <span class="keyword">import</span> <span class="include">AssemblyKeys._</span>&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;object TestWithSparkKeys {
    lazy val testAssembled        = TaskKey&lt;a href=<span class="string"><span class="delimiter">&quot;</span><span class="content">&amp;quot;test-assembled&amp;quot;,</span><span class="delimiter">&quot;</span></span> title=<span class="string"><span class="delimiter">&quot;</span><span class="content">Run tests with standalone Spark cluster</span><span class="delimiter">&quot;</span></span>&gt;Unit&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">a&gt;</span></span><span class="error">
</span>    lazy val assembledTestsProp   = SettingKey&lt;a href=<span class="string"><span class="delimiter">&quot;</span><span class="content">&amp;quot;assembled-tests-prop&amp;quot;,</span><span class="delimiter">&quot;</span></span> title=<span class="string"><span class="delimiter">&quot;</span><span class="content">Environment variable name used to pass assembled jar name to test</span><span class="delimiter">&quot;</span></span>&gt;<span class="predefined-type">String</span>&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">a&gt;</span></span><span class="error">
</span>  }&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;lazy val <span class="key">baseTestWithSparkSettings</span>: Seq[sbt.Def.Setting[_]] = Seq(
    testAssembled        := TestWithSpark.testWithSparkTask.value,
    assembledTestsProp   := <span class="error">“</span>ASSEMBLED_TESTS<span class="error">”</span>
  )&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;lazy val <span class="key">testWithSparkSettings</span>: Seq[sbt.Def.Setting[_]] = baseTestWithSparkSettings&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;object TestWithSpark {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;pre&gt;&lt;code&gt;<span class="keyword">def</span> <span class="key">assemblyTestsJarTask</span>: Initialize[Task[<span class="predefined-type">File</span>]] = Def.task {
  val assembled = (assembly <span class="keyword">in</span> Test).value
  sys.props(assembledTestsProp.value) = assembled.getAbsolutePath
  assembled
}

<span class="directive">private</span> <span class="keyword">def</span> runTests = Def.task {
  (test <span class="keyword">in</span> Test).value
}

<span class="keyword">def</span> <span class="key">testWithSparkTask</span>: Initialize[Task[Unit]] = Def.sequentialTask {
  assemblyTestsJarTask.value
  runTests.value
}   } } </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p>All Apache Spark tests should inherit <code>ConfiguredSparkFlatSpec</code> with configured Spark Context. If assembled tests jar file
is available, it’s distributed to Spark worker nodes. If not, only local mode is supported.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
trait ConfiguredSparkFlatSpec <span class="directive">extends</span> FlatSpec with BeforeAndAfterAll {
  <span class="directive">private</span> val log = LoggerFactory.getLogger(classOf[ConfiguredSparkFlatSpec])&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="directive">private</span> val config = ConfigFactory.load()&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="directive">private</span> lazy val sparkConf = {
    val master = config.getString(<span class="error">“</span>spark.master<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;pre&gt;&lt;code&gt;log.info(s<span class="string"><span class="delimiter">&quot;</span><span class="content">Create spark context. Master: </span><span class="inline"><span class="inline-delimiter">$</span>master</span><span class="delimiter">&quot;</span></span>)
val assembledTests = sys.props.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">ASSEMBLED_TESTS</span><span class="delimiter">&quot;</span></span>)

val baseConf = <span class="keyword">new</span> SparkConf().
  setMaster(master).
  setAppName(<span class="string"><span class="delimiter">&quot;</span><span class="content">SparkTestingExample</span><span class="delimiter">&quot;</span></span>)

assembledTests match {
  <span class="keyword">case</span> None =&amp;gt;
    log.warn(s<span class="string"><span class="delimiter">&quot;</span><span class="content">Assembled tests jar not found. Standalone Spark mode is not supported</span><span class="delimiter">&quot;</span></span>)
    baseConf
  <span class="keyword">case</span> Some(path) =&amp;gt;
    log.info(s<span class="string"><span class="delimiter">&quot;</span><span class="content">Add assembled tests to Spark Context from: </span><span class="inline"><span class="inline-delimiter">$</span>path</span><span class="delimiter">&quot;</span></span>)
    baseConf.setJars(path :: Nil)
}   }
&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">code&gt;&lt;</span><span class="delimiter">/</span></span>pre&gt;

&lt;p&gt;lazy val sc = <span class="keyword">new</span> SparkContext(sparkConf)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;override <span class="directive">protected</span> <span class="keyword">def</span> <span class="function">afterAll</span>(): Unit = {
    <span class="local-variable">super</span>.afterAll()
    sc.stop()
  }
}
</pre></div>
</div>
 </figure></notextile></div></p>

<p> </p>

<h3 id="running-tests">Running Tests</h3>

<p>By default <code>spark.master</code> property is set to local[2]. So you can run tests in local mode. If you want run tests
in standalone Apache Spark, you need to override <code>spark.master</code> with your master node.</p>

<p>If you’ll try to run <code>test</code> command with standalone cluster it will fail with ClassNotFoundException</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
&amp;gt; sbt -Dspark.master=spark://spark-host:7777 test
&amp;gt;
&amp;gt; Create spark context. Master: spark://Eugenes-MacBook-Pro.local:7077
&amp;gt; Assembled tests jar not found. Standalone Spark mode is not supported
&amp;gt;
&amp;gt; [error] Failed tests:
&amp;gt; org.apache.spark.SparkException: Job aborted due to stage failure:
&amp;gt; Task 2 in stage 1.0 failed 4 times, most recent failure:
&amp;gt; Lost task 2.3 in stage 1.0 (TID 30, 192.168.0.11):
&amp;gt; java.lang.ClassNotFoundException: com.scalafi.openbook.OpenBookMsg
</pre></div>
</div>
 </figure></notextile></div></p>

<p>However <code>test-assembled</code> will be successfull</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
&amp;gt; sbt -Dspark.master=spark://spark-host:7777 test-assembled
&amp;gt;
&amp;gt; Create spark context. Master: spark://Eugenes-MacBook-Pro.local:7077
&amp;gt; Add assembled tests to Spark Context from: /Users/ezhulenev/spark-testing/target/scala-2.10/spark-testing-example-tests.jar
&amp;gt;
&amp;gt; [info] Run completed in 7 seconds, 587 milliseconds.
&amp;gt; [info] Total number of tests run: 2
&amp;gt; [info] Suites: completed 1, aborted 0
&amp;gt; [info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 0
&amp;gt; [info] All tests passed.
&amp;gt; [success] Total time: 37 s
</pre></div>
</div>
 </figure></notextile></div></p>

<p> </p>

<blockquote>
  <p>The code for this application app can be found on <a href="https://github.com/ezhulenev/spark-testing">Github</a></p>
</blockquote>
]]></content>
  </entry>
  
</feed>
