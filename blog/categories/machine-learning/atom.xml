<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Machine Learning | Eugene Zhulenev]]></title>
  <link href="http://eugenezhulenev.com/blog/categories/machine-learning/atom.xml" rel="self"/>
  <link href="http://eugenezhulenev.com/"/>
  <updated>2016-02-24T16:51:11-05:00</updated>
  <id>http://eugenezhulenev.com/</id>
  <author>
    <name><![CDATA[Eugene Zhulenev]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Large Scale Deep Learning With TensorFlow on EC2 Spot Instances]]></title>
    <link href="http://eugenezhulenev.com/blog/2016/02/01/deep-learning-with-tensorflow-on-ec2-spot-instances/"/>
    <updated>2016-02-01T11:14:16-05:00</updated>
    <id>http://eugenezhulenev.com/blog/2016/02/01/deep-learning-with-tensorflow-on-ec2-spot-instances</id>
    <content type="html"><![CDATA[<p>In this post I’m demonstrating how to combine together <strong>TensorFlow</strong>, <strong>Docker</strong>, <strong>EC2 Container Service</strong> and <strong>EC2 Spot Instances</strong> 
to solve massive cluster computing problems the most cost-effective way.</p>

<blockquote>
  <p>Source code is on on Github: <a href="https://github.com/ezhulenev/distributo">https://github.com/ezhulenev/distributo</a></p>
</blockquote>

<p>Neural Networks and Deep Learning in particular gained a lot of attention over the last year, and it’s only the beginning. Google released
to open source their numerical computing framework <a href="https://www.tensorflow.org/">TensorFlow</a>, which can be used for training and running
deep neural networks for wide variety of machine learning problems, especially image recognition.</p>

<blockquote>
  <p>TensorFlow was originally developed by researchers and engineers working on the Google Brain Team within Google’s Machine Intelligence research 
organization for the purposes of conducting machine learning and deep neural networks research, but the system is general enough to be 
applicable in a wide variety of other domains as well.</p>
</blockquote>

<p>Although TensorFlow version used at Google supports distributed training, open sourced version can run only on one node. However some of machine learning
problems are still embarrassingly parallel, and can be easily parallelized regardless of single-node nature of the core library itself.</p>

<ol>
  <li><strong>Hyperparameter optimization</strong> or <strong>model selection</strong> is the problem of choosing a set of hyperparameters for a learning algorithm, 
usually with the goal of optimizing a measure of the algorithm’s performance on an independent data set. Naturally parallelized by training
models for each set ot parameters in parallel and choosing the best model (parameters) later.</li>
  <li><strong>Inference</strong> (applying trained model to new data) can be parallelized by splitting input dataset into smaller 
batches and running trained model on each of them in parallel</li>
</ol>

<!-- more -->

<h2 id="hyperparameter-optimization">Hyperparameter Optimization</h2>

<p>TensorFlow provides primitives for expressing and solving various numerical computations using data flow graphs, and it was primarily designed to solve
neural networks research problems.</p>

<p>Choosing a right design and parameters for your neural network is separate optimization problem:  </p>

<ul>
  <li>how many layers to use?</li>
  <li>how many neurons in each layer?</li>
  <li>what learning rate to use?</li>
</ul>

<p>These choices form a set of model hyperparameters, which can be used for training multiple models in parallel.</p>

<p><img class="center" src="/images/deep-learning/hyperparameter-optimization.png" title="Hyperparameter Optimization" ></p>

<h2 id="inference">Inference</h2>

<p>When you already have trained model, and you want to score/classify huge dataset, you can use similar approach: split all your input
data into smaller batches, and run them in parallel. Instead of different hyperparameters, scheduler will control batch offsets 
defining what part of the dataset should be loaded for inference.</p>

<h1 id="tensorflow-for-image-recognition">TensorFlow for Image Recognition</h1>

<h2 id="packaging-into-docker-image">Packaging into Docker Image</h2>

<p>TensorFlow has awesome <a href="https://www.tensorflow.org/versions/0.6.0/tutorials/image_recognition/index.html">Image Recognition Tutorial</a>, which uses already
pre-trained ImageNet model for image recognition/classification. You provide an image, and a model gives you what it 
can see on this image: leopard, container ship, place, etc.. Works like magic.</p>

<p>I’ve prepared <a href="https://github.com/ezhulenev/distributo/tree/master/example/docker-tensorflow">Docker image</a> based on official TensorFlow image 
and slightly modified image classification example. It takes a range of images that needs to be classified, and S3 
path where to put results:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
# You have to provider your AWS credentials to upload files on S3
# and S3 bucket name
docker run -it -e ‘AWS_ACCESS_KEY_ID=…’ -e ‘AWS_SECRET_ACCESS_KEY=…’ \
        ezhulenev/distributo-tensorflow-example \
        0:100 s3://distributo-example/imagenet/inferred-0-100.txt
</pre></div>
</div>
 </figure></notextile></div></p>

<p>This command will classify first 100 images from <a href="http://image-net.org/imagenet_data/urls/imagenet_fall11_urls.tgz">http://image-net.org/imagenet_data/urls/imagenet_fall11_urls.tgz</a>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
n00005787&lt;em&gt;175   http://farm3.static.flickr.com/2179/2090355369&lt;/em&gt;4c8a60f899.jpg
n00005787&lt;em&gt;185   http://farm4.static.flickr.com/3205/2815917575_c2ea596ed2.jpg
n00005787&lt;/em&gt;186   http://farm3.static.flickr.com/2084/2517885309&lt;em&gt;6680a79ab1.jpg
n00005787&lt;/em&gt;190   http://farm1.static.flickr.com/81/245539781&lt;em&gt;42028c8c67.jpg
n00005787&lt;/em&gt;198   http://farm2.static.flickr.com/1437/680424989&lt;em&gt;da45c42286.jpg
n00005787&lt;/em&gt;219   http://farm1.static.flickr.com/176/441681804_fec8ae4c58.jpg
</pre></div>
</div>
 </figure></notextile></div></p>

<p>And upload inference results to S3:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
n00005787&lt;em&gt;175,http://farm3.static.flickr.com/2179/2090355369&lt;/em&gt;4c8a60f899.jpg,[
  (‘brain coral’, 0.354022), 
  (‘hen-of-the-woods, hen of the woods, Polyporus frondosus, Grifola frondosa’, 0.18448937), 
  (‘coral reef’, 0.15611894), 
  (‘gyromitra’, 0.035839655), 
  (‘coral fungus’, 0.03291795)
]
n00005787_185,http://farm4.static.flickr.com/3205/2815917575_c2ea596ed2.jpg,[
  (‘sea slug, nudibranch’, 0.4032793), 
  (‘sea cucumber, holothurian’, 0.17277676), 
  (‘hermit crab’, 0.043269496),
  (‘conch’, 0.036443222), 
  (‘jellyfish’, 0.023511186)
]
</pre></div>
</div>
 </figure></notextile></div></p>

<h2 id="moving-into-the-aws-cloud">Moving into the AWS Cloud</h2>

<p>Amazon has <a href="https://aws.amazon.com/ecs/">EC2 Container Service (ECS)</a>, which is container management service that supports Docker containers,
and allows to easily launch any task packaged into container on EC2 instances using simple API. You don’t have to worry about managing
your cluster or installing any additional software. It just works out of the box with Amazon provided AMIs.</p>

<p>ECS clusters are running on regular EC2 instances, and it’s up to you what instances to use. One option, that especially makes sense
for large offline model training/inference it to use <a href="https://aws.amazon.com/ec2/spot/">EC2 Spot Instances</a> which allow you to bid on spare EC2 
computing capacity. Spot instances are usually available at a big discount compared to On-Demand pricing, this allows to 
significantly reduce the cost of running computation, and scale only when price allows to do so.</p>

<h1 id="distributo">Distributo</h1>

<p>Distributo is a small library that makes it easier to automate EC2 resource allocation on spot market, 
and provides custom ECS scheduler that takes care of efficient execution of your tasks on available computing resources.</p>

<p>Source code is on Github: <a href="https://github.com/ezhulenev/distributo">https://github.com/ezhulenev/distributo</a>. </p>

<p>It requires <a href="http://leiningen.org/">Leiningen</a> to compile and to run example application.</p>

<h3 id="resource-allocator">Resource Allocator</h3>

<p>Resource allocator is responsible for allocating compute resources in EC2 based on outstanding 
jobs resource requirements. Right now it’s lame implementation that only supports fixed
size ECS cluster built from same type spot instances. You need to define upfront how many instances do you need.</p>

<h3 id="scheduler">Scheduler</h3>

<p>Scheduler decides on what available container instance to start pending jobs. It’s using bin-packing 
with fitness calculators (concept borrowed from <a href="https://github.com/Netflix/Fenzo/wiki/Fitness-Calculators">Netflix/Fenzo</a>) to 
choose best instance to start new task. It’s the main difference from default ECS scheduler that
places tasks on random instances.</p>

<h2 id="run-tensorflow-image-recognition-with-distributo">Run TensorFlow Image Recognition with Distributo</h2>

<p>Distributo uses AWS JAVA SDK to access your AWS credentials. If you don’t have them already configured you
can do it with AWS CLI</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
aws configure
</pre></div>
</div>
 </figure></notextile></div></p>

<p>After that you can start you cluster and run TensorFlow inference with this command:    </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
lein run –inference \
  –num-instances 1 \
  –batch-size 100 \
  –num-batches 10 \
  –output s3://distributo-example/imagenet/
</pre></div>
</div>
 </figure></notextile></div></p>

<p>This command will run 10 TensorFlow containers with batches from <code>[0:100]</code> up to <code>[900:1000]</code> on single instance and 
put inference results into S3 bucket. By default it’s buying <code>m4.large</code> instances for <code>$0.03</code> which can run only 2 containers 
in parallel, in this example 10 jobs will be competing for 1 instance.</p>

<p>Distributo doesn’t free resources after it’s done with inference. If you are done, don’t forget to clean resources:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
lein run –free-resources
</pre></div>
</div>
 </figure></notextile></div></p>

<h2 id="future-work">Future Work</h2>

<p>Resource allocator and scheduler could be much more clever about their choices of regions, availability zones 
and instance types to be able to build most price-effective cluster out of resources currently 
available on spot market.</p>

<p><a href="https://github.com/twosigma/Cook">TwoSigma/Cook</a> - has lot’s of great ideas about fair resource allocation and cluster 
sharing for large scale batch computations, which might be very interesting to implement</p>

<h2 id="alternative-approaches">Alternative Approaches</h2>

<h3 id="spark-as-distributed-compute-engine">Spark as Distributed Compute Engine</h3>

<p>Apache Spark has Python integration and it’s possible to achieve very similar parallelization 
with it: <a href="https://databricks.com/blog/2016/01/25/deep-learning-with-spark-and-tensorflow.html">https://databricks.com/blog/2016/01/25/deep-learning-with-spark-and-tensorflow.html</a>.</p>

<p>However it’s completely different from approach that I described, because it doesn’t allow to use Docker (easily) and requires non trivial cluster setup. Although it might be more powerful
because it’s much easier to build more complicated pipelines.</p>

<h3 id="aws-auto-scaling">AWS Auto Scaling</h3>

<p>ECS provides auto scaling out of the box, also it has it’s own task scheduler. However task scheduler use random 
containers to place new tasks, which can lead to unefficient resource utilization. And with custom resource allocator it’s 
possible to build more sophisticated strategies for buying cheapest computing resources on fluctuating market.</p>

<h3 id="mesos">Mesos</h3>

<p>Mesos also provides great API for running tasks packaged as Docker images in the cluster.</p>

<p>However managing Mesos deployment is not trivial task, and you might not want to do have this headache. Also it’s much more difficult to provide
truly scalable platform, you’ll have to provision your cluster for peak load, which can be expensive and not cost-effective.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark in Production: Lessons From Running Large Scale Machine Learning]]></title>
    <link href="http://eugenezhulenev.com/blog/2015/12/03/spark-in-production-large-scale-machine-learning/"/>
    <updated>2015-12-03T13:24:46-05:00</updated>
    <id>http://eugenezhulenev.com/blog/2015/12/03/spark-in-production-large-scale-machine-learning</id>
    <content type="html"><![CDATA[<p>I wrote earlier about our approach for <a href="/blog/2015/09/09/audience-modeling-with-spark-ml-pipelines">machine learning with Spark</a> 
at <a href="http://collective.com">Collective</a>, it was focused on transforming raw data into features that can be used for training a model.
At this post I want describe how to assemble multiple building blocks into production application, that efficiently uses
Spark cluster and can train/validate hundreds of models.</p>

<p>Training single model is relatively easy, and it’s well covered in Spark documentation and multiple other blog posts. Training hundreds of 
models can become really tricky from engineering point of view. Spark has lot’s of configuration parameters 
that can affect cluster performance and stability, and you can use some clever tricks to get higher cluster utilization.</p>

<!-- more -->

<h3 id="scale-of-the-problem">Scale Of The Problem</h3>

<p>At Collective we are using Spark and machine learning for online advertising optimization, trying to decide which ads are relevant to 
which people, at which time and at which web site. </p>

<p>Log data used for training models is huge, billions of rows. Number of users that we target is hundreds of millions. 
We have hundreds of clients with tens of different campaigns, with different optimization targets and restrictions.</p>

<p>These factors gives an idea of the scale of the problem.  </p>

<h3 id="production-machine-learning-pipeline">Production Machine Learning Pipeline</h3>

<p>Typical machine learning pipeline for one specific ad campaign looks like this:</p>

<ul>
  <li><em>Prepare response dataset:</em> based on impression/activity logs define which users should be in positive set (did some actions that we are trying to optimize for, example could be signing up for test drive)</li>
  <li><em>Prepare train dataset:</em> extract predictors data from logs</li>
  <li><em>Feauturize:</em> given predictors data extract feature vectors</li>
  <li><em>Train model:</em> feed features and response data into Spark ML</li>
  <li><em>Prepare test dataset:</em> data that is going to be used for model performance evaluation</li>
  <li><em>Evaluate model:</em> for binary classification it can be computing ROC and AUC</li>
</ul>

<p>Preparing datasets is usually contains of multiple join and filter conditions. Featurization and training built on top 
of <a href="https://databricks.com/blog/2015/01/07/ml-pipelines-a-new-high-level-api-for-mllib.html">Spark ML Pipeline</a> API, and 
compose multiple transformers and estimators together. It’s covered in <a href="/blog/2015/09/09/audience-modeling-with-spark-ml-pipelines">one of previous posts</a>.</p>

<p>Given different nature of each step they have different limiting factors. Preparing dataset is expensive operation and heavily 
uses shuffle. Model training time is usually dominated by network latency introduced by iterative function optimization algorithm.</p>

<p>Serial execution of these steps can’t efficiently utilize all executor cores. Running multiple models in parallel in our 
case doesn’t really help as well, multiple models reach <em>modeling</em> stage at almost the same time.</p>

<h3 id="introducing-scalaz-stream">Introducing Scalaz-Stream</h3>

<p>I’ll just put first paragraph from amazing <a href="https://gist.github.com/djspiewak/d93a9c4983f63721c41c">Introduction to scalaz-stream</a> here:</p>

<blockquote>
  <p>Every application ever written can be viewed as some sort of transformation on data. Data can come from different sources, such as a network or a file or user input or the Large Hadron Collider. It can come from many sources all at once to be merged and aggregated in interesting ways, and it can be produced into many different output sinks, such as a network or files or graphical user interfaces. You might produce your output all at once, as a big data dump at the end of the world (right before your program shuts down), or you might produce it more incrementally. Every application fits into this model.</p>
</blockquote>

<p>We model machine learning pipeline as a <code>scalaz.stream.Process</code> - multistep transformation on data, and use <code>scalaz-stream</code> combinators to run it
with controlled concurrency and resource safety.</p>

<p>Simple domain model for campaign optimization can be defined like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="keyword">case</span> <span class="type">class</span> <span class="class">OptimizedCampaign</span>(<span class="key">id</span>: Int, <span class="key">input</span>: Input, <span class="key">target</span>: <span class="predefined-type">Target</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">case</span> <span class="type">class</span> <span class="class">ModelingError</span>(<span class="key">error</span>: <span class="predefined-type">String</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">case</span> <span class="type">class</span> <span class="class">TrainedAndEvaluatedModel</span>(<span class="error">…</span>)
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Input would be definition of campaign that needs to be optimized, and output would be model that was trained and evaluated or error if something went wrong.</p>

<p>Each of modeling steps described earlier can be encoded as <code>scalaz.stream.Channel</code> transformations:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">import</span> <span class="include">scalaz.stream._</span>&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val prepareResponse = 
  channel.lift[Task, OptimizedCampaign, ModelingError <span class="error">\</span>/ ResponseDataset] {
    <span class="keyword">case</span> opt =&amp;gt;
       <span class="comment">// Expensive join/filter etc…</span>
       val <span class="key">response</span>: DataFrame = 
         dataset1
           .join(dataset2, <span class="error">…</span>)
           .filter(..)
           .select(<span class="error">…</span>)
       ResponseDataset(response)
  }&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val prepareTrainDataset = lift[ResponseDataset, TrainDataset] {
  <span class="keyword">case</span> response =&amp;gt;
    <span class="comment">// Another expensive joins that requires shuffle</span>
    val <span class="key">train</span>: DataFrame = 
      dataset1.join(dataset2, <span class="error">…</span>).filter(<span class="error">…</span>)
    TrainDataset(train)&lt;br /&gt;
}&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val featurize = lift[TrainDataset, FeaturizedDataset] {
  <span class="keyword">case</span> train =&amp;gt; 
     <span class="comment">// Compute featurization using ML Pipeline API</span>
     val pipeline = <span class="keyword">new</span> Pipeline()
       .setStages(<span class="predefined-type">Array</span>(encodeSites, encodeS2Cells, assemble, lr))
     pipeline.fit(train.dataFrame).transform(train.dataFrame)&lt;br /&gt;
}&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val trainModel = lift[FeaturizedDataset, TrainedModel] {
  <span class="keyword">case</span> featurized =&amp;gt; 
    <span class="comment">// Train model with featurized data </span>
    val lr = <span class="keyword">new</span> LogisticRegression().set(<span class="error">…</span>)
    val pipeline = <span class="keyword">new</span> Pipeline().setStages(<span class="predefined-type">Array</span>(encode, lr))
    val evaluator = <span class="keyword">new</span> BinaryClassificationEvaluator() &lt;br /&gt;
    val crossValidator = <span class="keyword">new</span> CrossValidator()
      .setEstimator(pipeline)
      .setEvaluator(evaluator)  &lt;br /&gt;
    val paramGrid = <span class="keyword">new</span> ParamGridBuilder()
      .addGrid(lr.elasticNetParam, <span class="predefined-type">Array</span>(<span class="float">0.1</span>, <span class="float">0.5</span>))
      .build()  &lt;br /&gt;
    val model = crossValidator.fit(featurized.dataFrame)
    TrainedModel(model)
}&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val prepareTestDataset = lift[TrainedModel, TestDataset] {
  <span class="keyword">case</span> model =&amp;gt; <span class="error">…</span>
} &lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val evaluateModel = lift[TestDataset, TrainedAndEvaluatedModel] {
  <span class="keyword">case</span> test =&amp;gt; <span class="error">…</span>
}&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Helper method that allows each step to </span>
<span class="comment">// return &lt;code&gt;ModelingError \/ Result&lt;/code&gt; and nicely chains it together</span>
<span class="directive">private</span> <span class="keyword">def</span> lift&lt;a href=<span class="string"><span class="delimiter">&quot;</span><span class="content">f: A =&amp;gt; ModelingError </span><span class="content">\/</span><span class="content"> B</span><span class="delimiter">&quot;</span></span>&gt;A, B&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">a&gt; = {</span></span><span class="error">
</span>  channel.lift[Task, ModelingError <span class="error">\</span>/ A, ModelingError <span class="error">\</span>/ B] {
      <span class="keyword">case</span> -<span class="error">\</span><span class="regexp"><span class="delimiter">/</span><span class="content">(err) =&amp;gt; Task.now(</span><span class="char">\/</span><span class="content">.left(err))</span></span><span class="error">
</span>      <span class="keyword">case</span> <span class="error">\</span><span class="regexp"><span class="delimiter">/</span><span class="content">-(a) =&amp;gt; task(f(a))</span></span><span class="error">
</span>    }
}
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Given previously defined modeling steps, optimization pipeline can be defined as <code>Process</code> transformation.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="keyword">def</span> <span class="function">optimize</span>(
  <span class="key">campaigns</span>: <span class="predefined-type">Process</span>[Task, OptimizedCampaign]
): <span class="predefined-type">Process</span>[Task, ModelingError <span class="error">\</span>/ TrainedAndEvaluatedModel] = {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;campaigns
    .concurrently(<span class="integer">2</span>)(prepareResponse)
    .concurrently(<span class="integer">2</span>)(prepareTrainDataset)
    .concurrently(<span class="integer">2</span>)(featurize)
    .concurrently(<span class="integer">10</span>)(trainModel)
    .concurrently(<span class="integer">2</span>)(prepareTestDataset)
    .concurrently(<span class="integer">2</span>)(evaluateModel)
}
</pre></div>
</div>
 </figure></notextile></div></p>

<p>I’m using <code>concurrently</code> method, which runs each step with controlled concurrency in separate threads. Steps that are doing heavy shuffles 
are running not more than 2 in parallel, in contrast to model training that is relatively lightweight operation and can run with much higher
concurrency. This helper method is described in <a href="/blog/2015/09/09/audience-modeling-with-spark-ml-pipelines">earlier post</a>.</p>

<h4 id="push-vs-pull-based-streams">Push vs Pull Based Streams</h4>

<p><code>scalaz-steam</code> uses pull based model, it means that not first step (prepare response) is pushing data down the transformation chain when it’s ready, but
the bottom step (evaluate model) asks the previous step for new data when it’s done.</p>

<p>This allows to keep Spark cluster always busy, for example when relatively slow running modeling step is done, it 
asks <code>featurize</code> for new data, and it’s already there, which means that modeling can start immediately.</p>

<h3 id="spark-cluster-tuning">Spark Cluster Tuning</h3>

<p>For better cluster utilization I suggest to use <code>FAIR</code> scheduler mode, that can be turned on with <code>--conf spark.scheduler.mode=FAIR</code> flag.</p>

<p>Another big problem for us was tuning garbage collection. I’ve spent a lot of time trying to tune <code>G1</code> collector, but <code>ConcMarkSweepGC</code> with <code>ParNewGC</code> showed the best results
in our case. It doesn’t guarantee that it’s also the best choice for your particular case.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
–conf spark.executor.extraJavaOptions=”-server -XX:+AggressiveOpts -XX:-UseBiasedLocking -XX:NewSize=4g -XX:MaxNewSize=4g -XX:+UseParNewGC -XX:MaxTenuringThreshold=2 -XX:SurvivorRatio=4 -XX:+UnlockDiagnosticVMOptions -XX:ParGCCardsPerStrideChunk=32768 -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -XX:+PrintGCDetails -XX:+PrintAdaptiveSizePolicy -XX:+PrintTenuringDistribution -XX:+PrintGCDateStamps”
–driver-java-options “-server -XX:+AggressiveOpts -XX:-UseBiasedLocking -XX:NewSize=4g -XX:MaxNewSize=4g -XX:+UseParNewGC -XX:MaxTenuringThreshold=2 -XX:SurvivorRatio=4 -XX:+UnlockDiagnosticVMOptions -XX:ParGCCardsPerStrideChunk=32768 -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+ParallelRefProcEnabled -XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -XX:+PrintGCDetails -XX:+PrintAdaptiveSizePolicy -XX:+PrintTenuringDistribution -XX:+PrintGCDateStamps -Xloggc:gc.log” 
</pre></div>
</div>
 </figure></notextile></div></p>

<h3 id="streams-everywhere">Streams Everywhere</h3>

<p><code>scalaz-stream</code> is a great abstraction and as it’s described in <a href="https://gist.github.com/djspiewak/d93a9c4983f63721c41c">scalaz-stream Introduction</a> <em>every</em> application <em>can</em>, and I believe <strong>should be</strong> modeled this way.</p>

<p>This approach is embraced not only in scala community, but also in clojure, take a look for example at 
Rich Hickey presentation about <a href="http://www.infoq.com/presentations/clojure-core-async">clojure core.async channels</a>, and how your application can
be modeled with queues.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimizing Spark Machine Learning for Small Data]]></title>
    <link href="http://eugenezhulenev.com/blog/2015/09/16/spark-ml-for-big-and-small-data/"/>
    <updated>2015-09-16T10:04:25-04:00</updated>
    <id>http://eugenezhulenev.com/blog/2015/09/16/spark-ml-for-big-and-small-data</id>
    <content type="html"><![CDATA[<blockquote>
  <p><strong>Update 2015-10-08</strong>: Optimization “hack” described in this post still works, however we don’t use it in production anymore. 
With careful parallelism config, overhead introduced by distributed models is negligible.</p>
</blockquote>

<p>You’ve all probably already know how awesome is Spark for doing Machine Learning on Big Data. However I’m pretty sure
no one told you how bad (slow) it can be on Small Data. </p>

<p>As I mentioned in my <a href="/blog/2015/09/09/audience-modeling-with-spark-ml-pipelines">previous post</a>, we
extensively use Spark for doing machine learning and audience modeling. It turned out that in some cases, for example when
we are starting optimization for new client/campaign we simply don’t have enough positive examples to construct big enough dataset, so that
using Spark would make sense.</p>

<!-- more -->

<h3 id="spark-ml-from-10000-feet">Spark ML from 10000 feet</h3>

<p>Essentially every machine learning algorithm is a function minimization, where function value depends on some calculation using data in <code>RDD</code>.
For example logistic regression can calculate function value 1000 times before it will converge and find optimal parameters. It means that it will 
compute some <code>RDD</code> 1000 times. In case of <code>LogisticRegression</code> it’s doing <code>RDD.treeAggregate</code> which is supper efficient, but still it’s distributed 
computation.</p>

<p>Now imagine that all the data you have is 50000 rows, and you have for example 1000 partitions. It means that each partition has only 50 rows. And 
each <code>RDD.treeAggregate</code> on every iteration serializing closures, sending them to partitions and collecting result back. 
It’s <strong>HUGE OVERHEAD</strong> and huge load on a driver.</p>

<h3 id="throw-away-spark-and-use-pythonr">Throw Away Spark and use Python/R?</h3>

<p>It’s definitely an option, but we don’t want to build multiple systems for data of different size. Spark ML pipelines are awesome abstraction,
and we want to use it for all machine learning jobs. Also we want to use the same algorithm, so results would be consistent if dataset size
just crossed the boundary between small and big data.</p>

<h3 id="run-logisticregression-in-local-mode">Run LogisticRegression in ‘Local Mode’</h3>

<p>What if Spark could run the same machine learning algorithm, but instead of using <code>RDD</code> for storing input data, it would use <code>Arrays</code>?
It solves all the problems, you get consistent model, computed 10-20x faster because it doesn’t need distributed computations.</p>

<p>That’s exactly approach I used in <a href="https://github.com/collectivemedia/spark-ext">Spark Ext</a>, it’s called <a href="https://github.com/collectivemedia/spark-ext/blob/b61d73bbf6ce38c6b9fe37764934f37b640081fb/sparkext-mllib/src/main/scala/org/apache/spark/ml/classification/LocalLogisticRegression.scala">LocalLogisticRegression</a>.
It’s mostly copy-pasta from Spark <code>LogisticRegression</code>, but when input data frame has only single partition, it’s running
function optimization on one of the executors using <code>mapPartition</code> function, essentially using Spark as distributed executor service.</p>

<p>This approach is much better than collecting data to driver, because you are not limited by driver computational resources.</p>

<p>When <code>DataFrame</code> has more than 1 partition it just falls back to default distributed logistic regression.</p>

<p>Code for new <code>train</code> method looks like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="keyword">def</span> <span class="function">trainLocal</span>(
      <span class="key">instances</span>: <span class="predefined-type">Array</span>[(<span class="predefined-type">Double</span>, <span class="predefined-type">Vector</span>)]
    ): (LogisticRegressionModel, <span class="predefined-type">Array</span>[<span class="predefined-type">Double</span>]) = <span class="error">…</span>&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">def</span> <span class="function">train</span>(<span class="key">dataset</span>: DataFrame): LogisticRegressionModel = {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">if</span> (dataset.rdd.partitions.length == <span class="integer">1</span>) {
    log.info(s<span class="error">”</span>Build LogisticRegression <span class="keyword">in</span> local mode<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;pre&gt;&lt;code&gt;val (model, objectiveHistory) = extractLabeledPoints(dataset).map {
  <span class="keyword">case</span> LabeledPoint(<span class="key">label</span>: <span class="predefined-type">Double</span>, <span class="key">features</span>: <span class="predefined-type">Vector</span>) =&amp;gt; (label, features)
}.mapPartitions { instances =&amp;gt;
  Seq(trainLocal(instances.toArray)).toIterator
}.first()

val logRegSummary = <span class="keyword">new</span> BinaryLogisticRegressionTrainingSummary(
  model.transform(dataset),
  probabilityCol,
  labelCol,
  objectiveHistory)
model.setSummary(logRegSummary)
&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">code&gt;&lt;</span><span class="delimiter">/</span></span>pre&gt;

&lt;p&gt;} <span class="keyword">else</span> {
    log.info(s<span class="error">”</span>Fallback to distributed LogisticRegression<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;pre&gt;&lt;code&gt;val that = classOf[LogisticRegression].getConstructor(classOf[<span class="predefined-type">String</span>]).newInstance(uid)
val logisticRegression = copyValues(that)
<span class="comment">// Scala Reflection magic to call protected train method</span>
...
logisticRegression.train(dataset)   } }       </pre></div>
</div>
 </figure></notextile></div>
</code></pre>

<p>If input dataset size is less than 100000 rows, it will be placed inside single partition, and regression model will be trained in local mode.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
val <span class="key">base</span>: DataFrame = <span class="error">…</span>
val datasetPartitionSize = <span class="integer">100000</span>&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Compute optimal partitions size based on base join</span>
val baseSize = base.count()
val numPartitions = (baseSize.toDouble / datasetPartitionSize).ceil.toInt
log.debug(s<span class="error">”</span>Response base <span class="key">size</span>: <span class="error">$</span>baseSize<span class="error">”</span>)
log.debug(s<span class="error">”</span>Repartition dataset using <span class="error">$</span>numPartitions partitions<span class="error">”</span>)
</pre></div>
</div>
 </figure></notextile></div></p>

<h2 id="results">Results</h2>

<p>With a little ingenuity (and copy paste) Spark became perfect tool for machine learning both on Small and Big Data. Most awesome thing is that this
new <code>LocalLogisticRegression</code> can be used as drop in replacement in Spark ML pipelines, producing exactly the same <code>LogisticRegressionModel</code> at the end.</p>

<p>It might be interesting idea to use this approach in Spark itself, because in this case it would be possible to do it
without doing so many code duplication. I’d love to see if anyone else had the same problem, and how solved it.</p>

<blockquote>
  <p>More cool Spark things in <a href="https://github.com/collectivemedia/spark-ext/">Github</a>.</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Audience Modeling With Spark ML Pipelines]]></title>
    <link href="http://eugenezhulenev.com/blog/2015/09/09/audience-modeling-with-spark-ml-pipelines/"/>
    <updated>2015-09-09T09:04:25-04:00</updated>
    <id>http://eugenezhulenev.com/blog/2015/09/09/audience-modeling-with-spark-ml-pipelines</id>
    <content type="html"><![CDATA[<p>At <a href="http://collective.com">Collective</a> we are heavily relying on machine learning and predictive modeling to 
run digital advertising business. All decisions about what ad to show at this particular time to this particular user
are made by machine learning models (some of them are real time, and some of them are offline).</p>

<p>We have a lot of projects that uses machine learning, common name for all of them can be <strong>Audience Modeling</strong>, as they
all are trying to predict audience conversion (<em>CTR, Viewability Rate, etc…</em>) based on browsing history, behavioral segments and other type of 
predictors.</p>

<p>For most of new development we use <a href="https://spark.apache.org">Spark</a> and <a href="https://spark.apache.org/mllib/">Spark MLLib</a>. It is a awesome project,
however we found that some nice tools/libraries that are widely used for example in R are missing in Spark. In order to add missing
features that we would really like to have in Spark, we created <a href="https://github.com/collectivemedia/spark-ext">Spark Ext</a> - Spark Extensions
Library. </p>

<blockquote>
  <p>Spark Ext on Github: <a href="https://github.com/collectivemedia/spark-ext">https://github.com/collectivemedia/spark-ext</a></p>
</blockquote>

<p>I’m going to show simple example of combining <a href="https://github.com/collectivemedia/spark-ext">Spark Ext</a> with Spark ML pipelines for predicting user conversions based geo and browsing history data.</p>

<blockquote>
  <p>Spark ML pipeline example: <a href="https://github.com/collectivemedia/spark-ext/blob/master/sparkext-example/src/main/scala/com/collective/sparkext/example/SparkMlExtExample.scala">SparkMlExtExample.scala</a></p>
</blockquote>

<!-- more -->

<h2 id="predictors-data">Predictors Data</h2>

<p>I’m using dataset with 2 classes, that will be used for solving classification problem (user converted or not). It’s created with 
<a href="https://github.com/collectivemedia/spark-ext/blob/master/sparkext-example/src/main/scala/com/collective/sparkext/example/DataGenerator.scala">dummy data generator</a>, 
so that these 2 classes can be easily separated. It’s pretty similar to real data that usually available in digital advertising.</p>

<h3 id="browsing-history-log">Browsing History Log</h3>

<p>History of web sites that were visited by user.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
Cookie          | Site          | Impressions&lt;br /&gt;
————— |————– | ————-
wKgQaV0lHZanDrp | live.com      | 24
wKgQaV0lHZanDrp | pinterest.com | 21
rfTZLbQDwbu5mXV | wikipedia.org | 14
rfTZLbQDwbu5mXV | live.com      | 1
rfTZLbQDwbu5mXV | amazon.com    | 1
r1CSY234HTYdvE3 | youtube.com   | 10
</pre></div>
</div>
 </figure></notextile></div></p>

<h3 id="geo-location-log">Geo Location Log</h3>

<p>Latitude/Longitude impression history.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
Cookie          | Lat     | Lng       | Impressions
————— |———| ——— | ————
wKgQaV0lHZanDrp | 34.8454 | 77.009742 | 13
wKgQaV0lHZanDrp | 31.8657 | 114.66142 | 1
rfTZLbQDwbu5mXV | 41.1428 | 74.039600 | 20
rfTZLbQDwbu5mXV | 36.6151 | 119.22396 | 4
r1CSY234HTYdvE3 | 42.6732 | 73.454185 | 4
r1CSY234HTYdvE3 | 35.6317 | 120.55839 | 5
20ep6ddsVckCmFy | 42.3448 | 70.730607 | 21
20ep6ddsVckCmFy | 29.8979 | 117.51683 | 1
</pre></div>
</div>
 </figure></notextile></div></p>

<h2 id="transforming-predictors-data">Transforming Predictors Data</h2>

<p>As you can see predictors data (sites and geo) is in <em>long</em> format, each <code>cookie</code> has multiple rows associated with it,
and it’s in general is not a good fit for machine learning.
We’d like <code>cookie</code> to be a primary key, and all other data should form <code>feature vector</code>.</p>

<h3 id="gather-transformer">Gather Transformer</h3>

<p>Inspired by R <code>tidyr</code> and <code>reshape2</code> packages. Convert <em>long</em> <code>DataFrame</code> with values
for each key into <em>wide</em> <code>DataFrame</code>, applying aggregation function if single
key has multiple values.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
val gather = <span class="keyword">new</span> Gather()
      .setPrimaryKeyCols(<span class="error">“</span>cookie<span class="error">”</span>)
      .setKeyCol(<span class="error">“</span>site<span class="error">”</span>)
      .setValueCol(<span class="error">“</span>impressions<span class="error">”</span>)
      .setValueAgg(<span class="error">“</span>sum<span class="error">”</span>)         <span class="comment">// sum impression by key</span>
      .setOutputCol(<span class="error">“</span>sites<span class="error">”</span>)
val gatheredSites = gather.transform(siteLog)    &lt;br /&gt;
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
Cookie           | Sites
—————–|———————————————-
wKgQaV0lHZanDrp  | [
                 |  { site: live.com, impressions: 24.0 }, 
                 |  { site: pinterest.com, impressions: 21.0 }
                 | ]
rfTZLbQDwbu5mXV  | [
                 |  { site: wikipedia.org, impressions: 14.0 }, 
                 |  { site: live.com, impressions: 1.0 },
                 |  { site: amazon.com, impressions: 1.0 }
                 | ]
</pre></div>
</div>
 </figure></notextile></div></p>

<h3 id="google-s2-geometry-cell-id-transformer">Google S2 Geometry Cell Id Transformer</h3>

<p>The S2 Geometry Library is a spherical geometry library, very useful for manipulating regions on the sphere (commonly on Earth) 
and indexing geographic data. Basically it assigns unique cell id for each region on the earth. </p>

<blockquote>
  <p>Good article about S2 library: <a href="http://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/">Google’s S2, geometry on the sphere, cells and Hilbert curve</a></p>
</blockquote>

<p>For example you can combine S2 transformer with Gather to get from <code>lat</code>/<code>lon</code> to <code>K-V</code> pairs, where key will be <code>S2</code> cell id.
Depending on a level you can assign all people in Greater New York area (level = 4) into one cell, or you can index them block by block (level = 12).</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// Transform lat/lon into S2 Cell Id</span>
val s2Transformer = <span class="keyword">new</span> S2CellTransformer()
  .setLevel(<span class="integer">5</span>)
  .setCellCol(<span class="error">“</span>s2_cell<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Gather S2 CellId log</span>
val gatherS2Cells = <span class="keyword">new</span> Gather()
  .setPrimaryKeyCols(<span class="error">“</span>cookie<span class="error">”</span>)
  .setKeyCol(<span class="error">“</span>s2_cell<span class="error">”</span>)
  .setValueCol(<span class="error">“</span>impressions<span class="error">”</span>)
  .setOutputCol(<span class="error">“</span>s2_cells<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val gatheredCells = gatherS2Cells.transform(s2Transformer.transform(geoDf))
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
Cookie           | S2 Cells
—————–|———————————————-
wKgQaV0lHZanDrp  | [
                 |  { s2_cell: d5dgds, impressions: 5.0 }, 
                 |  { s2_cell: b8dsgd, impressions: 1.0 }
                 | ]
rfTZLbQDwbu5mXV  | [
                 |  { s2_cell: d5dgds, impressions: 12.0 }, 
                 |  { s2_cell: b8dsgd, impressions: 3.0 },
                 |  { s2_cell: g7aeg3, impressions: 5.0 }
                 | ]
</pre></div>
</div>
 </figure></notextile></div></p>

<h2 id="assembling-feature-vector">Assembling Feature Vector</h2>

<p><code>K-V</code> pairs from result of <code>Gather</code> are cool, and groups all the information about cookie into single row, however they can’t be used
as input for machine learning. To be able to train a model, predictors data needs to be represented as a vector of doubles. If all features are continuous and
numeric it’s easy, but if some of them are categorical or in <code>gathered</code> shape, it’s not trivial.</p>

<h3 id="gather-encoder">Gather Encoder</h3>

<p>Encodes categorical key-value pairs using dummy variables. </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// Encode S2 Cell data</span>
val encodeS2Cells = <span class="keyword">new</span> GatherEncoder()
  .setInputCol(<span class="error">“</span>s2_cells<span class="error">”</span>)
  .setOutputCol(<span class="error">“</span>s2_cells_f<span class="error">”</span>)
  .setKeyCol(<span class="error">“</span>s2_cell<span class="error">”</span>)
  .setValueCol(<span class="error">“</span>impressions<span class="error">”</span>)
  .setCover(<span class="float">0.95</span>) <span class="comment">// dimensionality reduction</span>
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
Cookie           | S2 Cells
—————–|———————————————-
wKgQaV0lHZanDrp  | [
                 |  { s2_cell: d5dgds, impressions: 5.0 }, 
                 |  { s2_cell: b8dsgd, impressions: 1.0 }
                 | ]
rfTZLbQDwbu5mXV  | [
                 |  { s2_cell: d5dgds, impressions: 12.0 }, 
                 |  { s2_cell: g7aeg3, impressions: 5.0 }
                 | ]
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Transformed into</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
Cookie           | S2 Cells Features
—————–|————————
wKgQaV0lHZanDrp  | [ 5.0  ,  1.0 , 0   ]
rfTZLbQDwbu5mXV  | [ 12.0 ,  0   , 5.0 ]
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Note that it’s 3 unique cell id values, that gives 3 columns in final feature vector.</p>

<p>Optionally apply dimensionality reduction using <code>top</code> transformation:</p>

<ul>
  <li>Top coverage, is selecting categorical values by computing the count of distinct users for each value,
sorting the values in descending order by the count of users, and choosing the top values from the resulting
list such that the sum of the distinct user counts over these values covers c percent of all users,
for example, selecting top sites covering 99% of users.</li>
</ul>

<h2 id="spark-ml-pipelines">Spark ML Pipelines</h2>

<p>Spark ML Pipeline - is new high level API for Spark MLLib. </p>

<blockquote>
  <p>A practical ML pipeline often involves a sequence of data pre-processing, feature extraction, model fitting, and validation stages. For example, classifying text documents might involve text segmentation and cleaning, extracting features, and training a classification model with cross-validation. <a href="https://databricks.com/blog/2015/01/07/ml-pipelines-a-new-high-level-api-for-mllib.html">Read More.</a> </p>
</blockquote>

<p>In Spark ML it’s possible to split ML pipeline in multiple independent stages, group them together in single pipeline and run it
with Cross Validation and Parameter Grid to find best set of parameters.</p>

<h3 id="put-it-all-together-with-spark-ml-pipelines">Put It All together with Spark ML Pipelines</h3>

<p>Gather encoder is a natural fit into Spark ML Pipeline API.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="comment">// Encode site data</span>
val encodeSites = <span class="keyword">new</span> GatherEncoder()
  .setInputCol(<span class="error">“</span>sites<span class="error">”</span>)
  .setOutputCol(<span class="error">“</span>sites_f<span class="error">”</span>)
  .setKeyCol(<span class="error">“</span>site<span class="error">”</span>)
  .setValueCol(<span class="error">“</span>impressions<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Encode S2 Cell data</span>
val encodeS2Cells = <span class="keyword">new</span> GatherEncoder()
  .setInputCol(<span class="error">“</span>s2_cells<span class="error">”</span>)
  .setOutputCol(<span class="error">“</span>s2_cells_f<span class="error">”</span>)
  .setKeyCol(<span class="error">“</span>s2_cell<span class="error">”</span>)
  .setValueCol(<span class="error">“</span>impressions<span class="error">”</span>)
  .setCover(<span class="float">0.95</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Assemble feature vectors together</span>
val assemble = <span class="keyword">new</span> VectorAssembler()
  .setInputCols(<span class="predefined-type">Array</span>(<span class="error">“</span>sites_f<span class="error">”</span>, <span class="error">“</span>s2_cells_f<span class="error">”</span>))
  .setOutputCol(<span class="error">“</span>features<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Build logistic regression</span>
val lr = <span class="keyword">new</span> LogisticRegression()
  .setFeaturesCol(<span class="error">“</span>features<span class="error">”</span>)
  .setLabelCol(<span class="error">“</span>response<span class="error">”</span>)
  .setProbabilityCol(<span class="error">“</span>probability<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Define pipeline with 4 stages</span>
val pipeline = <span class="keyword">new</span> Pipeline()
  .setStages(<span class="predefined-type">Array</span>(encodeSites, encodeS2Cells, assemble, lr))&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val evaluator = <span class="keyword">new</span> BinaryClassificationEvaluator()
  .setLabelCol(Response.response)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val crossValidator = <span class="keyword">new</span> CrossValidator()
  .setEstimator(pipeline)
  .setEvaluator(evaluator)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;val paramGrid = <span class="keyword">new</span> ParamGridBuilder()
  .addGrid(lr.elasticNetParam, <span class="predefined-type">Array</span>(<span class="float">0.1</span>, <span class="float">0.5</span>))
  .build()&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;crossValidator.setEstimatorParamMaps(paramGrid)
crossValidator.setNumFolds(<span class="integer">2</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;println(s<span class="error">”</span>Train model on train set<span class="error">”</span>)
val cvModel = crossValidator.fit(trainSet)
</pre></div>
</div>
 </figure></notextile></div></p>

<h2 id="conclusion">Conclusion</h2>

<p>New Spark ML API makes machine learning much more easier. <a href="https://github.com/collectivemedia/spark-ext">Spark Ext</a> is good example of how is it possible to 
create custom transformers/estimators that later can be used as a part of bigger pipeline, and can be easily shared/reused by multiple projects.</p>

<blockquote>
  <p>Full code for example application is available on <a href="https://github.com/collectivemedia/spark-ext/blob/master/sparkext-example/src/main/scala/com/collective/sparkext/example/SparkMlExtExample.scala">Github</a>.</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Feature Engineering at Scale With Spark]]></title>
    <link href="http://eugenezhulenev.com/blog/2015/06/10/feature-engineering-at-scale/"/>
    <updated>2015-06-10T23:02:45-04:00</updated>
    <id>http://eugenezhulenev.com/blog/2015/06/10/feature-engineering-at-scale</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Check Model Matrix <a href="http://collectivemedia.github.io/modelmatrix/">Website</a> and <a href="https://github.com/collectivemedia/modelmatrix">Github project</a>.</p>
</blockquote>

<p>At <a href="http://collective.com">Collective</a> we are in programmatic advertisement business, it means that all our
advertisement decisions (what ad to show, to whom and at what time) are driven by models. We do a lot of 
machine learning, build thousands predictive models and use them to make millions decision per second.</p>

<h4 id="how-do-we-get-the-most-out-of-our-data-for-predictive-modeling">How do we get the most out of our data for predictive modeling?</h4>

<p>Success of all Machine Learning algorithms depends on data that you put into it, the better the features you choose, the
better the results you will achieve.</p>

<blockquote>
  <p>Feature Engineering is the process of using domain knowledge of the data to create features that make machine learning algorithms work better.</p>
</blockquote>

<p>In Ad-Tech it’s finite pieces of information about users that we can put into our models, and it’s 
almost the same across all companies in industry, we don’t have access to any anonymous data
like real name and age, interests on Facebook etc. It really matter how creative you are to get maximum from the data you have,
and how fast you can iterate and test new idea.</p>

<p>In 2014 Collective data science team published <a href="http://arxiv.org/abs/1402.6076">Machine Learning at Scale</a> paper that
describes our approach and trade-offs for audience optimization. In 2015 we solve the same problems, but
using new technologies (Spark and Spark MLLib) at even bigger scale. I want to show the tool that I built specifically 
to handle feature engineering/selection problem, and which is open sources now.</p>

<h2 id="model-matrix">Model Matrix</h2>

<!-- more -->

<h3 id="feature-transformation">Feature Transformation</h3>

<p>Imagine impression log that is used to train predictive model</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
visitor_id  | ad_campaign     | ad_id | ad_ctr     | pub_site            | state | city         | price | timestamp   &lt;br /&gt;
———– | ————— | —– | ———- | ——————- | —– | ———— | —– | ————- 
bob         | Nike_Sport      | 1     | 0.01       | http://bbc.com      | NY    | New York     | 0.17  | 1431032702135&lt;br /&gt;
bill        | Burgers_Co      | 2     | 0.005      | http://cnn.com      | CA    | Los Angeles  | 0.42  | 1431032705167 
mary        | Macys           | 3     | 0.015      | http://fashion.com  | CA    | Los Angeles  | 0.19  | 1431032708384 
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Producing a feature vector for every visitor (cookie) row and every piece of information about a 
visitor as an p-size vector, where p is the number of predictor variables multiplied by cardinality 
of each variable (number of states in US, number of unique websites, etc …). It is impractical 
both from the data processing standpoint and because the resulting vector would only have 
about 1 in 100,000 non-zero elements.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
 visitor_id  | Nike_Sport | Burgers_Co | Macys | NY  | CA  | … 
 ———– | ———- | ———- | —– | — | — | — 
 bob         | 1.0        |            |       | 1.0 |     | … 
 bill        |            | 1.0        |       |     | 1.0 | … 
 mary        |            |            | 1.0   |     | 1.0 | … 
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Model Matrix uses feature transformations (top, index, binning) to reduce dimensionality to arrive 
at between one and two thousand predictor variables, with data sparsity of about 1 in 10. It removes 
irrelevant and low frequency predictor values from the model, and transforms continuous 
variable into bins of the same size.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre> &lt;br /&gt;
 visitor_id  | Nike | OtherAd | NY  | OtherState | price ∈ [0.01, 0.20) | price ∈ [0.20, 0.90) | … 
 ———– | —- | ——- | — | ———- | ——————– | ——————– | — 
 bob         | 1.0  |         | 1.0 |            | 1.0                  |                      | … 
 bill        |      | 1.0     |     | 1.0        |                      | 1.0                  | … 
 mary        |      | 1.0     |     | 1.0        |                      | 1.0                  | … 
</pre></div>
</div>
 </figure></notextile></div></p>

<p>Transformation definitions in scala:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
sealed trait Transform&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">/**
 * Absence of transformation
 */</span>
<span class="keyword">case</span> object <span class="predefined-type">Identity</span> <span class="directive">extends</span> Transform&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">/**
 * For distinct values of the column, find top values
 * by a quantity that cumulatively cover a given percentage
 * of this quantity. For example, find the top DMAs that
 * represent 99% of cookies, or find top sites that
 * are responsible for 90% of impressions.
 *
 * @param cover      cumulative cover percentage
 * @param allOther   include feature for all other values
 */</span>
<span class="keyword">case</span> <span class="type">class</span> <span class="class">Top</span>(<span class="key">cover</span>: <span class="predefined-type">Double</span>, <span class="key">allOther</span>: <span class="predefined-type">Boolean</span>) <span class="directive">extends</span> Transform&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">/**
 * For distinct values of the column, find the values
 * with at least the minimum support in the data set.
 * Support for a value is defined as the percentage of a
 * total quantity that have that value. For example,
 * find segments that appear for at least 1% of the cookies.
 *
 * @param support    support percentage
 * @param allOther   include feature for all other values
 */</span>
<span class="keyword">case</span> <span class="type">class</span> <span class="class">Index</span>(<span class="key">support</span>: <span class="predefined-type">Double</span>, <span class="key">allOther</span>: <span class="predefined-type">Boolean</span>) <span class="directive">extends</span> Transform&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">/**
 * Break the values in the column into bins with roughly the same number of points.
 *
 * @param nbins target number of bins
 * @param minPoints minimum number of points in single bin
 * @param minPercents minimum percent of points in a bin (0-100).
 *                    The larger of absolute number and percent points is used.
 */</span>
<span class="keyword">case</span> <span class="type">class</span> <span class="class">Bins</span>(<span class="key">nbins</span>: Int, <span class="key">minPoints</span>: Int = <span class="integer">0</span>, <span class="key">minPercents</span>: <span class="predefined-type">Double</span> = <span class="float">0.0</span>) <span class="directive">extends</span> Transform
</pre></div>
</div>
 </figure></notextile></div></p>

<h3 id="transformed-columns">Transformed Columns</h3>

<h4 id="categorical-transformation">Categorical Transformation</h4>

<p>A column calculated by applying top or index transform function, each columns id corresponds 
to one unique value from input data set. SourceValue is encoded as ByteVector unique value from 
input column and used later for featurization. </p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="type">class</span> <span class="class">CategoricalTransformer</span>(
  <span class="key">features</span>: DataFrame <span class="error">@</span><span class="error">@</span> <span class="predefined-type">Transformer</span>.Features
) <span class="directive">extends</span> <span class="predefined-type">Transformer</span>(features) {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">def</span> <span class="function">transform</span>(<span class="key">feature</span>: TypedModelFeature): Seq[CategoricalColumn]&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
sealed trait CategoricalColumn {
  <span class="keyword">def</span> <span class="key">columnId</span>: Int
  <span class="keyword">def</span> <span class="key">count</span>: <span class="predefined-type">Long</span>
  <span class="keyword">def</span> <span class="key">cumulativeCount</span>: <span class="predefined-type">Long</span>
}&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;object CategoricalColumn {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">case</span> <span class="type">class</span> <span class="class">CategoricalValue</span>(
    <span class="key">columnId</span>: Int,
    <span class="key">sourceName</span>: <span class="predefined-type">String</span>,
    <span class="key">sourceValue</span>: ByteVector,
    <span class="key">count</span>: <span class="predefined-type">Long</span>,
    <span class="key">cumulativeCount</span>: <span class="predefined-type">Long</span>
  ) <span class="directive">extends</span> CategoricalColumn &lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">case</span> <span class="type">class</span> <span class="class">AllOther</span>(
    <span class="key">columnId</span>: Int,
    <span class="key">count</span>: <span class="predefined-type">Long</span>,
    <span class="key">cumulativeCount</span>: <span class="predefined-type">Long</span>
  ) <span class="directive">extends</span> CategoricalColumn &lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;}
</pre></div>
</div>
 </figure></notextile></div></p>

<h4 id="bin-column">Bin Column</h4>

<p>A column calculated by applying binning transform function.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="type">class</span> <span class="class">BinsTransformer</span>(
  <span class="key">input</span>: DataFrame <span class="error">@</span><span class="error">@</span> <span class="predefined-type">Transformer</span>.Features
) <span class="directive">extends</span> <span class="predefined-type">Transformer</span>(input) with Binner {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="keyword">def</span> <span class="function">transform</span>(<span class="key">feature</span>: TypedModelFeature): Seq[BinColumn] = {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;}
</pre></div>
</div>
 </figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>
<span class="keyword">case</span> <span class="type">class</span> <span class="class">BinValue</span>(
    <span class="key">columnId</span>: Int,
    <span class="key">low</span>: <span class="predefined-type">Double</span>,
    <span class="key">high</span>: <span class="predefined-type">Double</span>,
    <span class="key">count</span>: <span class="predefined-type">Long</span>,
    <span class="key">sampleSize</span>: <span class="predefined-type">Long</span>
  ) 
</pre></div>
</div>
 </figure></notextile></div></p>

<h3 id="building-model-matrix-instance">Building Model Matrix Instance</h3>

<p>Model Matrix instance contains information about shape of the training data, what transformations (categorical and binning)
are required to apply to input data in order to obtain feature vector that will got into machine learning
algorithm.</p>

<p>Building model matrix instance described well in <a href="http://collectivemedia.github.io/modelmatrix/doc/cli.html">command line interface documentation</a>.</p>

<h3 id="featurizing-your-data">Featurizing your data</h3>

<p>When you have model matrix instance, you can apply it to multiple input data sets. For example in Collective
we build model matrix instance once a week or even month, and use it for building models from daily/hourly data.
It gives us nice property: all models have the same columns, and it’s easy to compare them.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="CodeRay">
  <div class="code"><pre>&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Similar to Spark LabeledPoint</span>
<span class="keyword">case</span> <span class="type">class</span> <span class="class">IdentifiedPoint</span>(<span class="key">id</span>: Any, <span class="key">features</span>: <span class="predefined-type">Vector</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="type">class</span> <span class="class">Featurization</span>(<span class="key">features</span>: Seq[ModelInstanceFeature]) <span class="directive">extends</span> <span class="predefined-type">Serializable</span> {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Check that all input features belong to the same model instance</span>
  <span class="directive">private</span> val instances = features.map(_.modelInstanceId).toSet
  require(instances.size == <span class="integer">1</span>, 
    s<span class="error">”</span>Features belong to different model <span class="key">instances</span>: <span class="error">$</span>instances<span class="error">”</span>)&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">// Maximum columns id in instance features</span>
  <span class="directive">private</span> val totalNumberOfColumns = features.flatMap {
    <span class="keyword">case</span> ModelInstanceIdentityFeature(&lt;em&gt;, _, _, _, columnId) =&amp;gt; Seq(columnId)
    <span class="keyword">case</span> ModelInstanceTopFeature(&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">em&gt;, &lt;em&gt;, _, _, cols) =&amp;gt; cols.map(&lt;</span><span class="delimiter">/</span></span>em&gt;.columnId)
    <span class="keyword">case</span> ModelInstanceIndexFeature(&lt;em&gt;, _, _, _, cols) =&amp;gt; cols.map(&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">em&gt;.columnId)</span></span><span class="error">
</span>    <span class="keyword">case</span> ModelInstanceBinsFeature(&lt;em&gt;, _, _, _, cols) =&amp;gt; cols.map(&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">em&gt;.columnId)</span></span><span class="error">
</span>  }.max&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;p&gt;<span class="comment">/**
   * Featurize input dataset
   *
   * @return id data type and featurized rows
   */</span>
  <span class="keyword">def</span> <span class="function">featurize</span>(
    <span class="key">input</span>: DataFrame <span class="error">@</span><span class="error">@</span> FeaturesWithId, 
    <span class="key">idColumn</span>: <span class="predefined-type">String</span>
  ): (DataType, RDD[IdentifiedPoint]) = {&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">p&gt;</span></span><span class="error">
</span>
&lt;pre&gt;&lt;code&gt;log.info(s<span class="string"><span class="delimiter">&quot;</span><span class="content">Extract features from input DataFrame with id column: </span><span class="inline"><span class="inline-delimiter">$</span>idColumn</span><span class="content">. </span><span class="delimiter">&quot;</span></span> + 
         s<span class="string"><span class="delimiter">&quot;</span><span class="content">Total number of columns: </span><span class="inline"><span class="inline-delimiter">$</span>totalNumberOfColumns</span><span class="delimiter">&quot;</span></span>)

...
&lt;<span class="regexp"><span class="delimiter">/</span><span class="content">code&gt;&lt;</span><span class="delimiter">/</span></span>pre&gt;

&lt;p&gt;}
}
</pre></div>
</div>
 </figure></notextile></div></p>

<h3 id="results">Results</h3>

<p>Model Matrix is open sourced, and available on <a href="https://github.com/collectivemedia/modelmatrix">Github</a>, lot’s of 
documentation on <a href="http://collectivemedia.github.io/modelmatrix/">Website</a>.</p>

<p>We use it at <a href="http://collective.com">Collective</a> to define our models and it works for us really well.</p>

<p>You can continue your reading with <a href="http://arxiv.org/abs/1402.6076">Machine Learning at Scale</a> paper, 
to get more data science focused details about our modeling approach.</p>
]]></content>
  </entry>
  
</feed>
